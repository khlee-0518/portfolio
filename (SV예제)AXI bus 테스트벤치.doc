ğŸ“ ì „ì²´ êµ¬ì„± ë¡œë“œë§µ
ë²ˆí˜¸
íŒŒì¼ëª…
ì„¤ëª…
1ï¸âƒ£
axi_if.sv
AXI4-Lite ì¸í„°í˜ì´ìŠ¤ ì •ì˜ + modport + clocking block
2ï¸âƒ£
axi_tx.sv
Read/Write íŠ¸ëœì­ì…˜ í´ë˜ìŠ¤ ì •ì˜
3ï¸âƒ£
axi_driver.sv
AXI Masterìš© read/write ë“œë¼ì´ë²„
4ï¸âƒ£
axi_monitor.sv
ì‹ í˜¸ ê°ì‹œìš© ëª¨ë‹ˆí„°
5ï¸âƒ£
axi_scoreboard.sv
ê¸°ëŒ€ê°’ê³¼ ì‹¤ì œ ê²°ê³¼ ë¹„êµìš© ìŠ¤ì½”ì–´ë³´ë“œ
6ï¸âƒ£
axi_env.sv
ë“œë¼ì´ë²„/ëª¨ë‹ˆí„°/ìŠ¤ì½”ì–´ë³´ë“œë¥¼ í¬í•¨í•œ í™˜ê²½ í´ë˜ìŠ¤
7ï¸âƒ£
axi_test.sv
ì‹œí€€ìŠ¤ ì‹¤í–‰ ë° ì‹œë‚˜ë¦¬ì˜¤ êµ¬ì„±
8ï¸âƒ£
axi_assertions.sv
AXI íƒ€ì´ë° ì œì•½ í™•ì¸ìš© Assertion
9ï¸âƒ£
axi_covergroup.sv
ì»¤ë²„ë¦¬ì§€ ìˆ˜ì§‘ì„ ìœ„í•œ Covergroup
ğŸ”Ÿ
dut.sv
Read/Write + Bì±„ë„ ì§€ì› DUT
ğŸ”Ÿ+1
top_tb.sv
í…ŒìŠ¤íŠ¸ë²¤ì¹˜ ìµœìƒë‹¨ ì—°ê²° ë° ì‹¤í–‰


ğŸ“„ 1ï¸âƒ£ axi_if.sv â€” AXI4-Lite ì¸í„°í˜ì´ìŠ¤
interface axi_if #(parameter ADDR_WIDTH = 32, DATA_WIDTH = 32)
  (input logic clk, input logic rst_n);

  // Write address channel
  logic                 AWVALID;
  logic [ADDR_WIDTH-1:0] AWADDR;
  logic                 AWREADY;

  // Write data channel
  logic                 WVALID;
  logic [DATA_WIDTH-1:0] WDATA;
  logic                 WREADY;

  // Write response channel
  logic                 BVALID;
  logic [1:0]           BRESP;
  logic                 BREADY;

  // Read address channel
  logic                 ARVALID;
  logic [ADDR_WIDTH-1:0] ARADDR;
  logic                 ARREADY;

  // Read data channel
  logic                 RVALID;
  logic [DATA_WIDTH-1:0] RDATA;
  logic [1:0]           RRESP;
  logic                 RREADY;

  // Clocking block for master
  clocking cb_master @(posedge clk);
    default input #1step output #1;
    output AWVALID, AWADDR, WVALID, WDATA, BREADY, ARVALID, ARADDR, RREADY;
    input  AWREADY, WREADY, BVALID, BRESP, ARREADY, RVALID, RDATA, RRESP;
  endclocking

  // Clocking block for slave (optional)
  clocking cb_slave @(posedge clk);
    default input #1step output #1;
    input  AWVALID, AWADDR, WVALID, WDATA, BREADY, ARVALID, ARADDR, RREADY;
    output AWREADY, WREADY, BVALID, BRESP, ARREADY, RVALID, RDATA, RRESP;
  endclocking

  // Modport ì„ ì–¸
  modport master (clocking cb_master, input clk, input rst_n);
  modport slave  (clocking cb_slave,  input clk, input rst_n);

endinterface


ğŸ§© ë‹¤ìŒìœ¼ë¡œ ì œê³µí•  íŒŒì¼ì€ axi_tx.sv ì…ë‹ˆë‹¤. Read/Write íŠ¸ëœì­ì…˜ì„ í¬í•¨í•œ í´ë˜ìŠ¤ ì •ì˜ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤.

ğŸ“„ 2ï¸âƒ£ axi_tx.sv â€” íŠ¸ëœì­ì…˜ í´ë˜ìŠ¤ (Read/Write ì§€ì›)
class axi_transaction;
  rand bit [31:0] addr;
  rand bit [31:0] data;
  rand bit        is_read; // 0: write, 1: read

  bit [1:0]       resp;
  bit [31:0]      rdata;

  function new(bit [31:0] a = 0, bit [31:0] d = 0, bit is_r = 0);
    addr    = a;
    data    = d;
    is_read = is_r;
  endfunction

  function string sprint(); //sprint í•¨ìˆ˜ëŠ” ì§ì ‘ í˜¸ì¶œì‹œì—ë§Œ ì‹¤í–‰ëœë‹¤.
    return $sformatf("[AXI TX] %s 0x%08h %s", 
                     is_read ? "READ from" : "WRITE to", 
                     addr, 
                     is_read ? "" : $sformatf("<= 0x%08h", data));
  endfunction
endclass


ğŸ“„ 3ï¸âƒ£ axi_driver.sv â€” Read/Write ë“œë¼ì´ë²„
class axi_driver;
  virtual axi_if.master vif; //virtualì„ í†µí•´ ì¸í„°í˜ì´ìŠ¤ì§€ë§Œ class ì²˜ëŸ¼ ì·¨ê¸‰

  function new(virtual axi_if.master vif);
    this.vif = vif; //ì™¸ë¶€ì—ì„œ virtual inferface ë¥¼ ë°›ì•„ í´ë˜ìŠ¤ ë§´ë²„ë³€ìˆ˜ì— ì €ì¥í•˜ê¸° ìœ„í•¨
  endfunction

  task drive(axi_transaction tx);
    vif.cb_master.AWVALID <= 0;
    vif.cb_master.WVALID  <= 0;
    vif.cb_master.ARVALID <= 0;
    vif.cb_master.BREADY  <= 1;
    vif.cb_master.RREADY  <= 1;
    #1;

    if (tx.is_read) begin
      // READ íŠ¸ëœì­ì…˜
      vif.cb_master.ARADDR  <= tx.addr;
      vif.cb_master.ARVALID <= 1;
      wait (vif.cb_master.ARREADY);
      vif.cb_master.ARVALID <= 0;

      wait (vif.cb_master.RVALID);
      tx.rdata = vif.cb_master.RDATA;
      tx.resp  = vif.cb_master.RRESP;
      $display("AXIDriver: READ 0x%08h from 0x%08h", tx.rdata, tx.addr);
    end else begin
      // WRITE íŠ¸ëœì­ì…˜
      vif.cb_master.AWADDR  <= tx.addr;
      vif.cb_master.AWVALID <= 1;
      wait (vif.cb_master.AWREADY);
      vif.cb_master.AWVALID <= 0;

      vif.cb_master.WDATA   <= tx.data;
      vif.cb_master.WVALID  <= 1;
      wait (vif.cb_master.WREADY);
      vif.cb_master.WVALID <= 0;

      wait (vif.cb_master.BVALID);
      tx.resp = vif.cb_master.BRESP;
      $display("AXIDriver: WRITE 0x%08h to 0x%08h", tx.data, tx.addr);
    end
  endtask
endclass


ğŸ“„ 4ï¸âƒ£ axi_monitor.sv â€” AXI ëª¨ë‹ˆí„°
class axi_monitor;
  virtual axi_if.slave vif;
  mailbox #(axi_transaction) mon2sb;

  function new(virtual axi_if.slave vif, mailbox #(axi_transaction) mbox);
    this.vif = vif;
    this.mon2sb = mbox;
  endfunction

  task run();
    forever begin
      // Write monitor
      if (vif.AWVALID && vif.AWREADY) begin
        axi_transaction tx = new();
        tx.addr = vif.AWADDR;
        wait (vif.WVALID && vif.WREADY);
        tx.data = vif.WDATA;
        tx.is_read = 0;
        mon2sb.put(tx);
      end
      // Read monitor
      if (vif.ARVALID && vif.ARREADY) begin
        axi_transaction tx = new();
        tx.addr = vif.ARADDR;
        tx.is_read = 1;
        mon2sb.put(tx);
      end
      #1;
    end
  endtask
endclass


ğŸ“„ 5ï¸âƒ£ axi_scoreboard.sv â€” Scoreboard
class axi_scoreboard;
  mailbox #(axi_transaction) mon2sb;

  bit [31:0] mem [0:255];

  function new(mailbox #(axi_transaction) mbox);
    this.mon2sb = mbox;
  endfunction

  task run();
    forever begin
      axi_transaction tx;
      mon2sb.get(tx);
      if (tx.is_read) begin
        bit [31:0] exp = mem[tx.addr[7:0]];
        if (tx.rdata !== exp)
          $error("Scoreboard: READ ERROR at 0x%08h: expected 0x%08h, got 0x%08h", tx.addr, exp, tx.rdata);
        else
          $display("Scoreboard: READ OK 0x%08h = 0x%08h", tx.addr, tx.rdata);
      end else begin
        mem[tx.addr[7:0]] = tx.data;
        $display("Scoreboard: WRITE OK 0x%08h <= 0x%08h", tx.addr, tx.data);
      end
    end
  endtask
endclass

ğŸ“„ 6ï¸âƒ£ axi_env.sv â€” í™˜ê²½ í´ë˜ìŠ¤
class axi_env;

  axi_driver     drv;
  axi_monitor    mon;
  axi_scoreboard sb;
  mailbox #(axi_transaction) mbox;

  virtual axi_if vif; //axi_if í˜¸ì¶œ

  function new(virtual axi_if vif);
    this.vif = vif; //ì´ë¯¸ í˜¸ì¶œí•œ virtual axi_if vif; ì— vif ë¥¼ ë„£ëŠ”ë‹¤
    mbox = new();
    drv = new(vif.master);
    mon = new(vif.slave, mbox);
    sb  = new(mbox);
  endfunction

  task run();
    fork
      mon.run();
      sb.run();
    join_none
  endtask

endclass


ğŸ“„ 7ï¸âƒ£ axi_test.sv â€” ì‹œí€€ìŠ¤ ë° í…ŒìŠ¤íŠ¸ ì‹¤í–‰
class axi_test;

  axi_env env;

  function new(virtual axi_if vif); //virtual ë¡œ axi_if í´ë˜ìŠ¤í™”í•´ì„œ env ì— ë„£ìŒ
    env = new(vif); //axi_env ì˜ function ì‹¤í–‰
  endfunction

  task run();
    env.run();

    axi_transaction tx1 = new(32'h10, 32'hDEADBEEF, 0); // write
    axi_transaction tx2 = new(32'h20, 32'hCAFEBABE, 0); // write
    axi_transaction tx3 = new(32'h10, 0, 1);            // read
    axi_transaction tx4 = new(32'h20, 0, 1);            // read

    #10; env.drv.drive(tx1);
    #10; env.drv.drive(tx2);
    #10; env.drv.drive(tx3);
    #10; env.drv.drive(tx4);

    #100;
  endtask

endclass


ğŸ“„ 8ï¸âƒ£ axi_assertions.sv â€” Assertion ëª¨ë“ˆ
module axi_assertions(input logic clk, input logic rst_n, axi_if vif);
  
  // Write address valid must be held until ready
  property aw_handshake;
    @(posedge clk) disable iff (!rst_n)
      vif.AWVALID |-> ##1 vif.AWREADY;
  endproperty
  assert property (aw_handshake) else $fatal("AW handshake failed");

  // Read address valid must be held until ready
  property ar_handshake;
    @(posedge clk) disable iff (!rst_n)
      vif.ARVALID |-> ##1 vif.ARREADY;
  endproperty
  assert property (ar_handshake) else $fatal("AR handshake failed");

endmodule


ğŸ“„ 9ï¸âƒ£ axi_covergroup.sv â€” ê¸°ëŠ¥ ì»¤ë²„ë¦¬ì§€
module axi_covergroup(input logic clk, input logic rst_n, axi_if vif);

  covergroup cg @(posedge clk iff (rst_n));
    addr_range: coverpoint vif.AWADDR[7:0] {
      bins low  = {[0:63]};
      bins high = {[64:255]};
    }

    rw_type: coverpoint {vif.AWVALID, vif.ARVALID} {
      bins write = (1, 0);
      bins read  = (0, 1);
    }
  endgroup

  cg cov = new();

endmodule


ğŸ“„ ğŸ”Ÿ dut.sv â€” DUT (AXI Read/Write/Bì±„ë„ ì§€ì›)
module dut (
  input  logic clk,
  input  logic rst_n,
  input  logic AWVALID,
  input  logic [31:0] AWADDR,
  output logic AWREADY,
  input  logic WVALID,
  input  logic [31:0] WDATA,
  output logic WREADY,
  output logic BVALID,
  output logic [1:0] BRESP,
  input  logic BREADY,
  input  logic ARVALID,
  input  logic [31:0] ARADDR,
  output logic ARREADY,
  output logic RVALID,
  output logic [31:0] RDATA,
  output logic [1:0] RRESP,
  input  logic RREADY
);

  logic [31:0] mem [0:255];

  // Registers for write
  logic aw_hs, w_hs;
  logic [31:0] wr_addr, wr_data;

  // Write Address Channel
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      AWREADY <= 1;
      WREADY  <= 1;
      BVALID  <= 0;
      BRESP   <= 2'b00;
    end else begin
      AWREADY <= !aw_hs;
      WREADY  <= !w_hs;

      if (AWVALID && AWREADY) begin
        wr_addr <= AWADDR;
        aw_hs <= 1;
      end

      if (WVALID && WREADY) begin
        wr_data <= WDATA;
        w_hs <= 1;
      end

      if (aw_hs && w_hs) begin
        mem[wr_addr[7:0]] <= wr_data;
        BVALID <= 1;
        BRESP <= 2'b00;
        aw_hs <= 0;
        w_hs  <= 0;
      end

      if (BVALID && BREADY) begin
        BVALID <= 0;
      end
    end
  end

  // Read Address Channel
  always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
      ARREADY <= 1;
      RVALID  <= 0;
    end else begin
      ARREADY <= 1;
      if (ARVALID && ARREADY) begin
        RDATA <= mem[ARADDR[7:0]];
        RVALID <= 1;
        RRESP  <= 2'b00;
      end

      if (RVALID && RREADY) begin
        RVALID <= 0;
      end
    end
  end
endmodule


ğŸ“„ ğŸ”Ÿ+1 top_tb.sv â€” Top-Level Testbench
`include "axi_tx.sv"
`include "axi_driver.sv"
`include "axi_monitor.sv"
`include "axi_scoreboard.sv"
`include "axi_env.sv"
`include "axi_test.sv"
`include "axi_if.sv"
`include "axi_assertions.sv"
`include "axi_covergroup.sv"

module top_tb;

  logic clk = 0;
  logic rst_n = 0;

  always #5 clk = ~clk;

  // Interface
  axi_if bus(clk, rst_n);

  // DUT
  dut u_dut (
    .clk(clk), .rst_n(rst_n),
    .AWVALID(bus.AWVALID), .AWADDR(bus.AWADDR), .AWREADY(bus.AWREADY),
    .WVALID(bus.WVALID), .WDATA(bus.WDATA), .WREADY(bus.WREADY),
    .BVALID(bus.BVALID), .BRESP(bus.BRESP), .BREADY(bus.BREADY),
    .ARVALID(bus.ARVALID), .ARADDR(bus.ARADDR), .ARREADY(bus.ARREADY),
    .RVALID(bus.RVALID), .RDATA(bus.RDATA), .RRESP(bus.RRESP), .RREADY(bus.RREADY)
  );

  // Assertion and coverage
  axi_assertions assert_inst(.clk(clk), .rst_n(rst_n), .vif(bus));
  axi_covergroup cover_inst(.clk(clk), .rst_n(rst_n), .vif(bus));

  initial begin
    $dumpfile("axi_test.vcd");
    $dumpvars(0, top_tb);

    rst_n = 0;
    #20 rst_n = 1;

    axi_test test = new(bus); //axi_test ì˜ ìƒì„±ìë¥¼ ì‹¤í–‰í•˜ì—¬ function í˜¸ì¶œ
    test.run(); //axi_test  ì˜ task run í˜¸ì¶œ

    #200 $finish;
  end
endmodule

âœ… ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼ (ì˜ˆìƒ ì¶œë ¥ ë¡œê·¸)
AXIDriver: WRITE 0xDEADBEEF to 0x00000010
Scoreboard: WRITE OK 0x00000010 <= 0xDEADBEEF

AXIDriver: WRITE 0xCAFEBABE to 0x00000020
Scoreboard: WRITE OK 0x00000020 <= 0xCAFEBABE

AXIDriver: READ 0xDEADBEEF from 0x00000010
Scoreboard: READ OK 0x00000010 = 0xDEADBEEF

AXIDriver: READ 0xCAFEBABE from 0x00000020
Scoreboard: READ OK 0x00000020 = 0xCAFEBABE


ì´ ì½”ë“œëŠ” ì•„ë˜ì™€ ê°™ì€ ìˆœì„œë¡œ ë™ì‘í•©ë‹ˆë‹¤:

ğŸ”¹ axi_test::new() â†’ axi_env::new() â†’ Driver, Monitor, Scoreboard ìƒì„±
ğŸ”¹ axi_test::run() â†’ env.run() â†’ monitor.run() + scoreboard.run() ì‹œì‘ (forked)

âœ… Assertion & Coverage
ğŸ“Œ Assertion
AWVALID â†’ AWREADY (Write addr)
ARVALID â†’ ARREADY (Read addr)
ì‹¤íŒ¨ ì‹œ: $fatal("... handshake failed")
â†’ ì´ í…ŒìŠ¤íŠ¸ì—ì„  ì„±ê³µí•˜ë¯€ë¡œ assertion í†µê³¼

ğŸ“Š Coverage
ì»¤ë²„í¬ì¸íŠ¸:
ì£¼ì†Œ ì˜ì—­ (low: 0â€“63, high: 64â€“255)
íŠ¸ëœì­ì…˜ íƒ€ì… (read vs write)
â†’ ì£¼ì†Œ 0x10, 0x20 â†’ low ì˜ì—­ì— í•´ë‹¹ â†’ read, write ë‘˜ ë‹¤ ìˆ˜í–‰ â†’ ë‘ bin ëª¨ë‘ hit

âœ… êµ¬ì¡°
master
  axi_test (addr,data,w/r) ì…ë ¥ -> axi_transaction  -> driver -> interface -> DUT
slave
  DUT ->  interface -> Monitor -> transaction -> mailbox -> transaction  -> SB
  DUT -> assertion
  DUT -> covertage


