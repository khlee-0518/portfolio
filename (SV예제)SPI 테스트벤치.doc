✅ 1. tb_spi_top (Top Testbench)
테스트의 최상위 모듈.
SPI master/slave 환경을 구성.
8개의 전송 시퀀스를 반복 실행.
시뮬레이션 종료 시 pass/fail 및 coverage 결과 출력.

✅ 2. spi_slave
SPI 슬레이브 동작 구현.
80비트 데이터 수신/송신.
수신 시 MOSI의 데이터를 rx_shift에 shift.
송신 시 rx_data_data 또는 tx_data_data를 shift.
유효한 80비트 수신 시 rx_data_valid 활성화.

✅ 3. spi_sequence
전송할 8개의 시퀀스 데이터를 생성.
각 시퀀스는 다음 필드로 구성됨:
Start of Data (0x7E)
Sensor Data 0 (24bit)
Checksum 0
Sensor Data 1 (24bit)
Checksum 1
End of Data (0x81)
FSM으로 start, done, restart 신호 제어.

✅ 4. spi_driver
Master 역할을 수행하는 SPI 드라이버.
시퀀스로부터 데이터를 받아 SPI로 전송.
내부 클럭 분주기와 상태 머신으로 전송 타이밍 제어.
전송이 끝나면 done 출력.

✅ 5. spi_monitor
SPI 신호를 모니터링하여 실제 수신된 데이터를 저장.
수신이 완료되면 rx_valid 활성화.
수신 데이터를 rx_trans로 출력.
디버깅 출력 포함.

✅ 6. spi_scoreboard
Monitor와 Sequence 데이터를 비교해 pass/fail 판단.
비교 결과에 따라 카운터 증가 및 로그 출력.
delay_data 모듈을 사용해 타이밍 동기화.

✅ 7. spi_checker
Assertion을 통해 SPI 제어 신호의 유효성 검증.
예: cs_n이 0일 때 sck 값이 유효해야 함.

✅ 8. spi_coverage
전달된 tx/rx 데이터를 기반으로 커버리지 측정.
covergroup과 bin_hit_count를 사용해 어떤 패턴이 몇 번 수행됐는지 추적.
모든 시퀀스가 한 번 이상 실행됐는지 체크함.

[spi_sequence] -> tx_seq
         |
         V
   [spi_driver] ---> spi bus ---> [spi_slave]
         |
         V
   [spi_monitor] -> rx_trans
         |
         V
  [spi_scoreboard] & [spi_coverage]




1. tb_spi_top .v
`timescale 1ns / 1ps
`include "spi_types.sv"
`include "spi_if.sv"

module tb_spi_top;

    import spi_types::*;

    logic clk;
    logic rst_n;

    spi_if spi();

    logic [79:0] slave_tx_data = 80'h0123456789ABCDEF1122;
    logic        slave_tx_valid = 1;

    // Clock generation
    always #5 clk = ~clk;

    parameter CLK_DIV = 50;

//    // Master instance
//    spi_master #(.CLK_DIV(CLK_DIV)) master (
//        .clk(clk),
//        .rst_n(rst_n),
//        .spi(spi),
//        .tx_req(driver_tx_seq),
//        .rx_resp(),
//        .busy()
//    );

    // Slave instance
    spi_slave slave (
        .clk(clk),
        .rst_n(rst_n),
        .spi_sck(spi.sck),
        .spi_mosi(spi.mosi),
        .spi_cs_n(spi.cs_n),
        .spi_miso(spi.miso),
        .rx_data_data(),
        .rx_data_valid(),
        .tx_data_data(slave_tx_data),
        .tx_data_valid(slave_tx_valid)
    );

    // Verification logic signals
    logic driver_start, driver_done, driver_busy;
    spi_tx_t driver_tx_seq;
    spi_rx_t monitor_rx_trans;
    logic monitor_rx_valid;
    logic end_wait, driver_done_gate, restart;
    integer i;

    // pass/fail counters
    logic [15:0] total_passed, total_failed;

    // Driver instance
    spi_driver driver (
        .clk(clk),
        .rst_n(rst_n),
        .spi(spi),
        .tx_seq(driver_tx_seq),
        .start(driver_start),
        .done(driver_done),
        .busy(driver_busy)
    );

    // Monitor instance
    spi_monitor monitor (
        .clk(clk),
        .rst_n(rst_n),
        .spi(spi),
        .rx_trans(monitor_rx_trans),
        .rx_valid(monitor_rx_valid)
    );

    // Scoreboard instance with pass/fail count outputs
    spi_scoreboard scoreboard (
        .clk(clk),
        .rst_n(rst_n),
        .tx_seq(driver_tx_seq),
        .rx_mon(monitor_rx_trans),
        .pass_count(total_passed),
        .fail_count(total_failed)
    );

    // Sequence generator instance
    spi_sequence spi_seq_inst (
        .clk(clk),
        .rst_n(rst_n),
        .tx_seq(driver_tx_seq),
        .start(driver_start),
        .done(driver_done),
        .restart(restart)
    );

    // Checker instance
    spi_checker spi_checker_inst (
        .clk(clk),
        .rst_n(rst_n),
        .spi(spi)
    );

    // Coverage instance
    spi_coverage coverage (
        .clk(clk),
        .rst_n(rst_n),
        .tx_seq(driver_tx_seq),
        .rx_mon(monitor_rx_trans)
    );

//  assign driver_done_gate = driver_done | end_wait;
    assign restart = end_wait;

    initial begin
        clk = 0;
        rst_n = 0;
        #20 rst_n = 1;

        end_wait = 0;
        // 충분한 시뮬레이션 시간 부여 (필요시 조절)
//        #100000;
        repeat (8) begin

            wait (driver_done==1);
            #10000; end_wait = 1;
            #10;    end_wait = 0;
        end

            $display("=========================");
            $display("== SIMULATION COMPLETED ==");
            $display("=========================");
   
            $display("\n=== SCOREBOARD SUMMARY ===");
            $display("Total Passed: %0d", total_passed);
            $display("Total Failed: %0d", total_failed);
   
            $display("\n=== COVERAGE SUMMARY ===");
            $display("Coverage group sampled.");
   
            if (total_failed == 0)
                $display(">>>  ALL TESTS PASSED");
            else
                $display(">>>  SOME TESTS FAILED");
        #1000;
        $finish;
    end

endmodule


2. spi_slave .v
`timescale 1ns / 1ps

module spi_slave (
    input  logic clk,
    input  logic rst_n,

    input  logic spi_sck,
    input  logic spi_mosi,
    input  logic spi_cs_n,
    output logic spi_miso,

    output logic [79:0] rx_data_data,
    output logic        rx_data_valid,
    input  logic [79:0] tx_data_data,
    input  logic        tx_data_valid
);

    logic [6:0] bit_cnt;
    logic [79:0] rx_shift, tx_shift;
    logic sck_d, sck_rising, sck_falling;
    logic [79:0] rx_data_data_reg;

    logic [ 7:0]    start_of_data   ;
    logic [23:0]    sensor_data_0   ;
    logic [ 7:0]    check_sum_0     ;
    logic [23:0]    sensor_data_1   ;
    logic [ 7:0]    check_sum_1     ;
    logic [ 7:0]    end_of_data     ;

    assign sck_rising  =  (spi_sck & ~sck_d);
    assign sck_falling = (~spi_sck &  sck_d);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            sck_d <= 0;
        else
            sck_d <= spi_sck;
    end

    // Receive
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_shift <= 0;
            bit_cnt  <= 0;
        end else if (!spi_cs_n) begin
            if (sck_rising) begin
                rx_shift <= {rx_shift[78:0], spi_mosi};
                bit_cnt  <= bit_cnt + 1;
            end
        end else begin
            bit_cnt <= 0;
        end
    end

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_data_data_reg <= 0;
        end else if (rx_data_valid) begin
            rx_data_data_reg <= rx_shift;
        end
    end
   
    assign rx_data_data  = rx_data_data_reg;
    assign rx_data_valid = (bit_cnt == 7'd80);

//  assign  start_of_data   [ 7:0] = rx_data_data_reg[0+0+ 7                    : 0+0];
//  assign  sensor_data_0   [23:0] = rx_data_data_reg[7+1+23                    : 7+1];
//  assign  check_sum_0     [ 7:0] = rx_data_data_reg[7+1+23+1+7                : 7+1+23+1];
//  assign  sensor_data_1   [23:0] = rx_data_data_reg[7+1+23+1+7+1+23           : 7+1+23+1+7+1];
//  assign  check_sum_1     [ 7:0] = rx_data_data_reg[7+1+23+1+7+1+23+1+7       : 7+1+23+1+7+1+23+1];
//  assign  end_of_data     [ 7:0] = rx_data_data_reg[7+1+23+1+7+1+23+1+7+1+7   : 7+1+23+1+7+1+23+1+7+1];

    assign  end_of_data     [ 7:0] = rx_data_data_reg[7                         : 0];
    assign  sensor_data_1   [23:0] = rx_data_data_reg[7+1+23                    : 7+1];
    assign  check_sum_1     [ 7:0] = rx_data_data_reg[7+1+23+1+7                : 7+1+23+1];
    assign  sensor_data_0   [23:0] = rx_data_data_reg[7+1+23+1+7+1+23           : 7+1+23+1+7+1];
    assign  check_sum_0     [ 7:0] = rx_data_data_reg[7+1+23+1+7+1+23+1+7       : 7+1+23+1+7+1+23+1];
    assign  start_of_data   [ 7:0] = rx_data_data_reg[7+1+23+1+7+1+23+1+7+1+7   : 7+1+23+1+7+1+23+1+7+1];

    // Transmit
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            tx_shift <= 0;
        else if (!spi_cs_n) begin
            if (bit_cnt == 0)
//                tx_shift <= tx_data_data;
                tx_shift <= rx_data_data;
            else if (sck_falling)
                tx_shift <= {tx_shift[78:0], 1'b0};
        end
    end

    assign spi_miso = tx_shift[79];

endmodule

3. spi_sequence.v 
`timescale 1ns/1ps
import spi_types::*;

module spi_sequence (
    input  logic clk,
    input  logic rst_n,
    output spi_tx_t tx_seq,
    output logic start,
    input  logic done,
    input  logic restart
);

    typedef enum logic [1:0] {IDLE, SEND, WAIT} state_t;
    state_t state, next_state;

    spi_tx_t tx_data_array [0:7];
    logic [2:0] index; // 3-bit enough for 8 vectors
   
    parameter WIDTH = 8;
    genvar i;
    logic [ 7:0]    start_of_data   = 8'h7e;
    logic [23:0]    sensor_data_0   [0:7];
    logic [ 7:0]    check_sum_0     [0:7];
    logic [23:0]    sensor_data_1   [0:7];
    logic [ 7:0]    check_sum_1     [0:7];
    logic [ 7:0]    end_of_data     = 8'h81;
    logic [79:0]    data_format     [0:7];

    assign sensor_data_0[0] = 24'h012E4F;   assign sensor_data_1[0] = 24'h012345;
    assign sensor_data_0[1] = 24'h022E4F;   assign sensor_data_1[1] = 24'h022345;
    assign sensor_data_0[2] = 24'h032E4F;   assign sensor_data_1[2] = 24'h032345;
    assign sensor_data_0[3] = 24'h042E4F;   assign sensor_data_1[3] = 24'h042345;
    assign sensor_data_0[4] = 24'h052E4F;   assign sensor_data_1[4] = 24'h052345;
    assign sensor_data_0[5] = 24'h062E4F;   assign sensor_data_1[5] = 24'h062345;
    assign sensor_data_0[6] = 24'h072E4F;   assign sensor_data_1[6] = 24'h072345;
    assign sensor_data_0[7] = 24'h082E4F;   assign sensor_data_1[7] = 24'h082345;

    generate
    for (i = 0; i < WIDTH; i = i + 1) begin
        assign check_sum_0[i]   = ~(sensor_data_0[i][23:16]+sensor_data_0[i][15:8]+sensor_data_0[i][7:0])+1;
        assign check_sum_1[i]   = ~(sensor_data_1[i][23:16]+sensor_data_1[i][15:8]+sensor_data_1[i][7:0])+1;
        assign data_format  [i] =   {start_of_data, sensor_data_0[i], check_sum_0[i], sensor_data_1[i], check_sum_1[i], end_of_data};
    end
    endgenerate


    // 데이터 배열은 초기화 그대로 둠
    initial begin
//        tx_data_array[0] = '{data: 80'hDEADBEEFCAFEBABEDEAD, valid: 1};
//        tx_data_array[1] = '{data: 80'h0123456789ABCDEF1122, valid: 1};
//        tx_data_array[2] = '{data: 80'hFFFFFFFFFFFFFFFFFFFF, valid: 1};
//        tx_data_array[3] = '{data: 80'h00000000000000000000, valid: 1};
//        tx_data_array[4] = '{data: 80'hAAAAAAAAAAAAAAAAAAAA, valid: 1};
//        tx_data_array[5] = '{data: 80'h55555555555555555555, valid: 1};
//        tx_data_array[6] = '{data: 80'h1234567890ABCDEF1234, valid: 1};
//        tx_data_array[7] = '{data: 80'hFEDCBA0987654321FEDC, valid: 1};
        tx_data_array[0] = '{data: data_format[0], valid: 1};
        tx_data_array[1] = '{data: data_format[1], valid: 1};
        tx_data_array[2] = '{data: data_format[2], valid: 1};
        tx_data_array[3] = '{data: data_format[3], valid: 1};
        tx_data_array[4] = '{data: data_format[4], valid: 1};
        tx_data_array[5] = '{data: data_format[5], valid: 1};
        tx_data_array[6] = '{data: data_format[6], valid: 1};
        tx_data_array[7] = '{data: data_format[7], valid: 1};
    end

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            index <= 0;
        end else begin
            state <= next_state;
            if (state == WAIT && restart && index < 7)
                index <= index + 1;
        end
    end

    always_comb begin
        next_state = state;
        start = 0;
        case(state)
            IDLE: if (index < 8) next_state = SEND;
            SEND: begin
                start = 1;
                if (done) next_state = WAIT;
            end
            WAIT: begin
                if (restart) next_state = IDLE;
            end
        endcase
    end

    assign tx_seq = tx_data_array[index];

endmodule

4. spi_driver.v
`timescale 1ns/1ps
import spi_types::*;

module spi_driver (
    input  logic        clk,
    input  logic        rst_n,
    spi_if.master       spi,
    output logic        busy,

    // transaction input from sequence
    input  spi_tx_t     tx_seq,
    input  logic        start,
    output logic        done
);

    typedef enum logic [1:0] {IDLE, TRANSFER} state_t;
    state_t state, next_state;

    logic [79:0] tx_shift;
    logic [6:0] bit_cnt;
    logic sck_int;
    logic start_reg;

    // 클럭 분주기 (fixed to 2 for driver)
    localparam CLK_DIV = 50;
    logic [15:0] clk_div_cnt;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) clk_div_cnt <= 0;
        else if (state == TRANSFER) clk_div_cnt <= (clk_div_cnt == CLK_DIV-1) ? 0 : clk_div_cnt + 1;
        else clk_div_cnt <= 0;
    end

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) sck_int <= 0;
        else if (state == TRANSFER && clk_div_cnt == CLK_DIV-1) sck_int <= ~sck_int;
        else if (state != TRANSFER) sck_int <= 0;
    end

    assign spi.sck = sck_int;
    assign spi.mosi = tx_shift[79];
    assign spi.cs_n = (state == TRANSFER) ? 0 : 1;

    // 상태 머신
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) state <= IDLE;
        else state <= next_state;
    end

    always_comb begin
        next_state = state;
        case(state)
            IDLE: if (start && !start_reg) next_state = TRANSFER;
            TRANSFER: if (bit_cnt == 7'd79 && clk_div_cnt == CLK_DIV-1 && sck_int == 1) next_state = IDLE;
        endcase
    end

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tx_shift <= 0;
            bit_cnt <= 0;
            done <= 0;
            busy <= 0;
            start_reg <= 0;
        end else begin
            done <= 0;
            busy <= (state == TRANSFER);
            start_reg <= start;
            case(state)
                IDLE: begin
                    bit_cnt <= 0;
                    if (start && !start_reg) begin
                        tx_shift <= tx_seq.data;
                    end
                end
                TRANSFER: begin
                    if (clk_div_cnt == CLK_DIV-1) begin
                        if (sck_int == 0) begin
                            // sample MISO handled by monitor
                        end else begin
                            tx_shift <= {tx_shift[78:0], 1'b0};
                            bit_cnt <= bit_cnt + 1;
                            if (bit_cnt == 7'd79)
                                done <= 1;
                        end
                    end
                end
            endcase
        end
    end
endmodule

5. spi_monitor 
`timescale 1ns/1ps
import spi_types::*;

module spi_monitor (
    input  logic        clk,
    input  logic        rst_n,
    spi_if.slave       spi,

    output spi_rx_t      rx_trans,
    output logic        rx_valid
);

    typedef enum logic [1:0] {IDLE, TRANSFER} state_t;
    state_t state;

    logic [79:0] rx_shift;
    logic [6:0] bit_cnt;
    logic sck_d;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            sck_d <= 0;
            state <= IDLE;
            bit_cnt <= 0;
            rx_shift <= 0;
        end else begin
            sck_d <= spi.sck;

            case(state)
                IDLE: begin
                    if (!spi.cs_n) begin
                        state <= TRANSFER;
                        bit_cnt <= 0;
                        rx_shift <= 0;
                    end
                end
                TRANSFER: begin
                    if (spi.cs_n) begin
                        state <= IDLE;
                    end else if (sck_d == 0 && spi.sck == 1) begin
//                        rx_shift <= {rx_shift[78:0], spi.miso};
                        rx_shift <= {rx_shift[78:0], spi.mosi};
                        bit_cnt <= bit_cnt + 1;
                    end
                end
            endcase
        end
    end

    logic rx_valid_d;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            rx_valid_d <= 0;
        else
            rx_valid_d <= rx_valid;
    end

    logic [79:0] rx_data_reg;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            rx_data_reg <= '0;
        else if (rx_valid && !rx_valid_d)  // rx_valid의 상승 엣지 감지
            rx_data_reg <= rx_shift;
    end


    assign rx_trans.data = rx_data_reg;
    assign rx_trans.valid = (bit_cnt == 80);
    assign rx_valid = (bit_cnt == 80);

    always_ff @(posedge clk) begin
//            if (bit_cnt == 80 && rx_valid_d==1) begin
            if (rx_valid && !rx_valid_d) begin
                $display("[%0t] MONITOR: Received data = 0x%020x", $time, rx_shift);
            end
    end


endmodule

6.spi_scoreboard 
`timescale 1ns/1ps
import spi_types::*;

module spi_scoreboard (
    input  logic        clk,
    input  logic        rst_n,
    input  spi_tx_t     tx_seq,
    input  spi_rx_t     rx_mon,
    output logic [15:0]  pass_count,
    output logic [15:0]  fail_count
);

    logic   [79:0]  tx_seq_data_4d;
    logic           rx_mon_valid_pls;

delay_data  #(
    .BIT_WIDTH      (80                 ),  //1~
    .NUM_DELAY      (4                  )   //1~
    )
    delay_data_tx_seq_data              (
    .aclk           (clk                ),
    .delay_array_i  (tx_seq.data        ),
    .delay_array_o  (tx_seq_data_4d     ),
    .aresetn        (rst_n              )
);
delay_data  #(
    .BIT_WIDTH      (1                  ),  //1~
    .NUM_DELAY      (1                  )   //1~
    )
    delay_data_rx_mon_val               (
    .aclk           (clk                ),
    .delay_array_i  (rx_mon.valid       ),
    .delay_array_o  (rx_mon_valid_1d    ),
    .aresetn        (rst_n              )
);
delay_data  #(
    .BIT_WIDTH      (1                  ),  //1~
    .NUM_DELAY      (1                  )   //1~
    )
    delay_data_rx_mon_valid_pls         (
    .aclk           (clk                ),
    .delay_array_i  (rx_mon_valid_pls   ),
    .delay_array_o  (rx_mon_valid_pls_1d),
    .aresetn        (rst_n              )
);

assign rx_mon_valid_pls = rx_mon.valid & !rx_mon_valid_1d;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pass_count <= 0;
            fail_count <= 0;
        end else begin
//            if (rx_mon.valid) begin
            if (rx_mon_valid_pls_1d) begin
//                if (rx_mon.data == tx_seq.data) begin
                if (rx_mon.data == tx_seq_data_4d) begin
                    pass_count <= pass_count + 1;
                    $display("[%0t] SCOREBOARD: PASS - Data match", $time);
                end else begin
                    fail_count <= fail_count + 1;
                    $display("[%0t] SCOREBOARD: FAIL - Expected: 0x%020x, Got: 0x%020x",
                             $time, tx_seq.data, rx_mon.data);
                end
            end
        end
    end

endmodule

7.spi_checker 
`timescale 1ns/1ps

module spi_checker (
    input logic clk,
    input logic rst_n,
    spi_if.slave spi
);

    // 간단한 assertion 예제: cs_n이 0일 때 sck가 반드시 0 또는 1인 상태 유지 (물리적으로 당연)

    // 여기에 추가 assertion 작성 가능

    // 예시
    property cs_active_implies_sck_valid;
        @(posedge clk) disable iff(!rst_n)
        (spi.cs_n == 0) |-> (spi.sck === 0 || spi.sck === 1);
    endproperty

    assert property (cs_active_implies_sck_valid)
        else $error("Invalid sck value when cs_n is active");

endmodule

8.spi_coverage 
`timescale 1ns/1ps
import spi_types::*;

module spi_coverage (
    input logic clk,
    input logic rst_n,
    input spi_tx_t tx_seq,
    input spi_rx_t rx_mon
);

    covergroup cg @(posedge clk);
        coverpoint tx_seq.data {
            bins example_bin[] = {80'hDEADBEEFCAFEBABEDEAD, 80'h0123456789ABCDEF1122};
        }
        coverpoint rx_mon.data;
        cross tx_seq.data, rx_mon.data;
    endgroup

    cg cg_inst;

    initial cg_inst = new();

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) ;
        else cg_inst.sample();
    end

    final begin
        $display("\n=== COVERAGE SUMMARY ===");
        $display("Coverage group sampled.");
        // 커버리지는 대부분 시뮬레이터 커버리지를 따로 봐야 합니다.
        // 이 메시지는 placeholder입니다.
    end

////////////////////////////////////////////////////////////////////////////////////////////////////
    parameter WIDTH = 8;
    genvar i;
    logic [ 7:0]    start_of_data   = 8'h7e;
    logic [23:0]    sensor_data_0   [0:7];
    logic [ 7:0]    check_sum_0     [0:7];
    logic [23:0]    sensor_data_1   [0:7];
    logic [ 7:0]    check_sum_1     [0:7];
    logic [ 7:0]    end_of_data     = 8'h81;
    logic [79:0]    data_format     [0:7];

    assign sensor_data_0[0] = 24'h012E4F;   assign sensor_data_1[0] = 24'h012345;
    assign sensor_data_0[1] = 24'h022E4F;   assign sensor_data_1[1] = 24'h022345;
    assign sensor_data_0[2] = 24'h032E4F;   assign sensor_data_1[2] = 24'h032345;
    assign sensor_data_0[3] = 24'h042E4F;   assign sensor_data_1[3] = 24'h042345;
    assign sensor_data_0[4] = 24'h052E4F;   assign sensor_data_1[4] = 24'h052345;
    assign sensor_data_0[5] = 24'h062E4F;   assign sensor_data_1[5] = 24'h062345;
    assign sensor_data_0[6] = 24'h072E4F;   assign sensor_data_1[6] = 24'h072345;
    assign sensor_data_0[7] = 24'h082E4F;   assign sensor_data_1[7] = 24'h082345;

    generate
    for (i = 0; i < WIDTH; i = i + 1) begin
        assign check_sum_0[i]   = ~(sensor_data_0[i][23:16]+sensor_data_0[i][15:8]+sensor_data_0[i][7:0])+1;
        assign check_sum_1[i]   = ~(sensor_data_1[i][23:16]+sensor_data_1[i][15:8]+sensor_data_1[i][7:0])+1;
        assign data_format  [i] =   {start_of_data, sensor_data_0[i], check_sum_0[i], sensor_data_1[i], check_sum_1[i], end_of_data};
    end
    endgenerate

gen_pulse       gen_pulse_rx_mon_valid  (
    .aclk       (clk                    ),
    .step_i     (rx_mon.valid           ),
    .pulse_o    (rx_mon_valid_pls       ),
    .aresetn    (rst_n                  )
);

localparam int NUM_BINS = 8;
int unsigned bin_hit_count[NUM_BINS];

always_ff @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        for (int i = 0; i < NUM_BINS; i++) begin
            bin_hit_count[i] <= 0;
        end
    end else if (rx_mon_valid_pls) begin
        case (tx_seq.data)
            data_format[0]: bin_hit_count[0] <= bin_hit_count[0] + 1;
            data_format[1]: bin_hit_count[1] <= bin_hit_count[1] + 1;
            data_format[2]: bin_hit_count[2] <= bin_hit_count[2] + 1;
            data_format[3]: bin_hit_count[3] <= bin_hit_count[3] + 1;
            data_format[4]: bin_hit_count[4] <= bin_hit_count[4] + 1;
            data_format[5]: bin_hit_count[5] <= bin_hit_count[5] + 1;
            data_format[6]: bin_hit_count[6] <= bin_hit_count[6] + 1;
            data_format[7]: bin_hit_count[7] <= bin_hit_count[7] + 1;
            default: ; // no match
        endcase
    end
end

final begin
    $display("\n=== Coverage Result ===");
    for (int i = 0; i < NUM_BINS; i++) begin
        $display("bin_%0x hit count = %0d", data_format[i], bin_hit_count[i]);
        if (bin_hit_count[i] == 0)
            $display("WARNING: bin_%0x was never hit!", data_format[i]);
    end
end



endmodule









      
