í™•ì¥ëœ ê¸°ëŠ¥(ì‹œë“œ ì œì–´, ëœë¤ íŠ¸ëœì­ì…˜ ìˆ˜, write-only ì˜µì…˜, ì»¤ë²„ë¦¬ì§€ í¬í•¨)ì„ ë°˜ì˜í•œ ì „ì²´ ì‹¤í–‰ ê°€ëŠ¥í•œ UVM í…ŒìŠ¤íŠ¸ë²¤ì¹˜ í”„ë¡œì íŠ¸ êµ¬ì¡°ë¥¼ í…ìŠ¤íŠ¸ í˜•íƒœë¡œ êµ¬ì„±í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

ğŸ“ ë””ë ‰í„°ë¦¬ êµ¬ì¡°
uvm_mem_project/
â”œâ”€â”€ dut/
â”‚   â”œâ”€â”€ mem_if.sv
â”‚   â””â”€â”€ simple_mem.sv
â”œâ”€â”€ uvm/
â”‚   â”œâ”€â”€ mem_transaction.sv
â”‚   â”œâ”€â”€ mem_sequence.sv
â”‚   â”œâ”€â”€ mem_sequencer.sv
â”‚   â”œâ”€â”€ mem_driver.sv
â”‚   â”œâ”€â”€ mem_monitor.sv
â”‚   â”œâ”€â”€ mem_agent.sv
â”‚   â”œâ”€â”€ mem_scoreboard.sv
â”‚   â”œâ”€â”€ mem_env.sv
â”‚   â””â”€â”€ mem_test.sv
â””â”€â”€ top.sv


ğŸ“˜ ì½”ë“œ êµ¬ì„±
ğŸ”¹ dut/mem_if.sv
systemverilog
ì½”ë“œ ë³µì‚¬
interface mem_if(input logic clk);
  logic [7:0] addr;
  logic [31:0] data;
  logic read_write;
  logic valid;
  logic ready;
endinterface

ğŸ”¹ dut/simple_mem.sv
systemverilog
ì½”ë“œ ë³µì‚¬
module simple_mem(input logic clk, reset,
                  input logic [7:0] addr,
                  input logic [31:0] data,
                  input logic read_write,
                  input logic valid,
                  output logic ready,
                  output logic [31:0] rdata);

  logic [31:0] mem [0:255];

  always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
      ready <= 0;
    end else if (valid) begin
      ready <= 1;
      if (read_write)
        mem[addr] <= data;
      rdata <= mem[addr];
    end else begin
      ready <= 0;
    end
  end
endmodule


ğŸ”¹ uvm/mem_transaction.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_transaction extends uvm_sequence_item;
  `uvm_object_utils(mem_transaction)

  rand bit [7:0] addr;
  rand bit [31:0] data;
  rand bit read_write;

  constraint addr_c { addr inside {[0:255]}; }

  function new(string name="mem_transaction");
    super.new(name);
  endfunction

  function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    mem_transaction tx;
    if (!$cast(tx, rhs)) return 0;
    return addr == tx.addr && data == tx.data && read_write == tx.read_write;
  endfunction
endclass


ğŸ”¹ uvm/mem_sequence.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_sequence extends uvm_sequence #(mem_transaction);
  `uvm_object_utils(mem_sequence)

  rand int unsigned num_trans = 100;
  rand bit write_ratio;

  constraint num_c { num_trans inside {[10:500]}; }

  function new(string name="mem_sequence");
    super.new(name);
  endfunction

  task body();
    for (int i = 0; i < num_trans; i++) begin
      mem_transaction tx = mem_transaction::type_id::create("tx");
      assert(tx.randomize() with {
        read_write == (write_ratio ? 1 : read_write);
      });
      start_item(tx);
      finish_item(tx);
    end
  endtask
endclass


ğŸ”¹ uvm/mem_sequencer.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_sequencer extends uvm_sequencer #(mem_transaction);
  `uvm_component_utils(mem_sequencer)
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
endclass


ğŸ”¹ uvm/mem_driver.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_driver extends uvm_driver #(mem_transaction);
  `uvm_component_utils(mem_driver)

  virtual mem_if vif;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (!uvm_config_db#(virtual mem_if)::get(this, "", "vif", vif))
      `uvm_fatal("NOVIF", "No virtual interface set")
  endfunction

  task run_phase(uvm_phase phase);
    forever begin
      mem_transaction tx;
      seq_item_port.get_next_item(tx);
      vif.addr <= tx.addr;
      vif.data <= tx.data;
      vif.read_write <= tx.read_write;
      vif.valid <= 1;
      @(posedge vif.clk);
      wait (vif.ready);
      vif.valid <= 0;
      seq_item_port.item_done();
    end
  endtask
endclass


ğŸ”¹ uvm/mem_monitor.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_monitor extends uvm_monitor;
  `uvm_component_utils(mem_monitor)

  virtual mem_if vif;
  uvm_analysis_port #(mem_transaction) item_collected_port;

  function new(string name, uvm_component parent);
    super.new(name, parent);
    item_collected_port = new("item_collected_port", this);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (!uvm_config_db#(virtual mem_if)::get(this, "", "vif", vif))
      `uvm_fatal("NOVIF", "No interface")
  endfunction

  task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.clk);
      if (vif.valid && vif.ready) begin
        mem_transaction tx = mem_transaction::type_id::create("tx");
        tx.addr = vif.addr;
        tx.data = vif.data;
        tx.read_write = vif.read_write;
        item_collected_port.write(tx);
      end
    end
  endtask
endclass


ğŸ”¹ uvm/mem_agent.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_agent extends uvm_agent;
  `uvm_component_utils(mem_agent)

  mem_sequencer sequencer;
  mem_driver    driver;
  mem_monitor   monitor;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    monitor = mem_monitor::type_id::create("monitor", this);
    if (get_is_active() == UVM_ACTIVE) begin
      sequencer = mem_sequencer::type_id::create("sequencer", this);
      driver    = mem_driver::type_id::create("driver", this);
    end
  endfunction

  function void connect_phase(uvm_phase phase);
    if (get_is_active() == UVM_ACTIVE)
      driver.seq_item_port.connect(sequencer.seq_item_export);
  endfunction
endclass


ğŸ”¹ uvm/mem_scoreboard.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_scoreboard extends uvm_subscriber #(mem_transaction);
  `uvm_component_utils(mem_scoreboard)

  mailbox expected;
  covergroup cg;
    coverpoint trans.read_write {
      bins read = {0};
      bins write = {1};
    }
  endgroup

  function new(string name, uvm_component parent);
    super.new(name, parent);
    expected = new();
    cg = new();
  endfunction

  virtual function void write(mem_transaction trans);
    cg.sample();
    expected.put(trans);
  endfunction
endclass


ğŸ”¹ uvm/mem_env.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_env extends uvm_env;
  `uvm_component_utils(mem_env)

  mem_agent      agent;
  mem_scoreboard sb;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    agent = mem_agent::type_id::create("agent", this);
    sb    = mem_scoreboard::type_id::create("sb", this);
  endfunction

  function void connect_phase(uvm_phase phase);
    agent.monitor.item_collected_port.connect(sb.analysis_export);
  endfunction
endclass


ğŸ”¹ uvm/mem_test.sv
systemverilog
ì½”ë“œ ë³µì‚¬
class mem_test extends uvm_test;
  `uvm_component_utils(mem_test)

  mem_env env;

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    env = mem_env::type_id::create("env", this);
  endfunction

  task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    mem_sequence seq = mem_sequence::type_id::create("seq");
    seq.start(env.agent.sequencer);
    phase.drop_objection(this);
  endtask
endclass


ğŸ”¹ top.sv
systemverilog
ì½”ë“œ ë³µì‚¬
`timescale 1ns/1ps
import uvm_pkg::*;
`include "uvm_macros.svh"

module top;
  logic clk = 0;
  logic reset;

  always #5 clk = ~clk;

  mem_if memif(clk);

  simple_mem dut (
    .clk(clk),
    .reset(reset),
    .addr(memif.addr),
    .data(memif.data),
    .read_write(memif.read_write),
    .valid(memif.valid),
    .ready(memif.ready),
    .rdata()
  );

  initial begin
    reset = 1;
    repeat (2) @(posedge clk);
    reset = 0;

    uvm_config_db#(virtual mem_if)::set(null, "env.agent.driver", "vif", memif);
    uvm_config_db#(virtual mem_if)::set(null, "env.agent.monitor", "vif", memif);
    run_test("mem_test");
  end
endmodule


ğŸ’¡ ì‹¤í–‰ ë°©ë²• ì˜ˆì‹œ (VCS or Questa)
bash
ì½”ë“œ ë³µì‚¬
vcs -full64 -sverilog +acc +vpi -ntb_opts uvm top.sv uvm/*.sv dut/*.sv
./simv +UVM_TESTNAME=mem_test
