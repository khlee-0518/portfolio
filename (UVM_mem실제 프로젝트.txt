uvm_mem_project/
â”œâ”€â”€ dut/
â”‚   â”œâ”€â”€ mem_if.sv
â”‚   â””â”€â”€ simple_mem.sv
â”œâ”€â”€ uvm/
â”‚   â”œâ”€â”€ mem_transaction.sv
â”‚   â”œâ”€â”€ mem_sequence.sv
â”‚   â”œâ”€â”€ mem_driver.sv
â”‚   â”œâ”€â”€ mem_monitor.sv
â”‚   â”œâ”€â”€ mem_agent.sv
â”‚   â”œâ”€â”€ mem_env.sv
â”‚   â”œâ”€â”€ mem_scoreboard.sv
â”‚   â””â”€â”€ mem_test.sv
â””â”€â”€ top.sv

ğŸ”Œ ì¸í„°í˜ì´ìŠ¤ ë° DUT
dut/mem_if.sv
interface mem_if(input logic clk);
  logic [7:0] addr;
  logic [31:0] data;
  logic read_write, valid, ready;
endinterface

dut/simple_mem.sv
module simple_mem(input logic clk, reset, 
                  input logic [7:0] addr,
                  input logic [31:0] data,
                  input logic read_write,
                  input logic valid,
                  output logic ready,
                  output logic [31:0] rdata);

  logic [31:0] mem [0:255];

  always_ff @(posedge clk or posedge reset) begin
    if (reset) ready <= 0;
    else if (valid) begin
      ready <= 1;
      if (read_write) mem[addr] <= data;
      rdata <= mem[addr];
    end else ready <= 0;
  end
endmodule


ğŸ§  UVM ì»´í¬ë„ŒíŠ¸
uvm/mem_transaction.sv
class mem_transaction extends uvm_sequence_item;
  `uvm_object_utils(mem_transaction)
  rand bit [7:0] addr;
  rand bit [31:0] data;
  rand bit read_write;
  constraint addr_c { addr inside {[0:255]}; }
  function new(string name="mem_transaction"); super.new(name); endfunction
  function bit do_compare(uvm_object rhs, uvm_comparer comparer);
    mem_transaction rhs_;
    if (!$cast(rhs_, rhs)) return 0;
    return addr == rhs_.addr && data == rhs_.data && read_write == rhs_.read_write;
  endfunction
endclass

uvm/mem_sequence.sv
class mem_sequence extends uvm_sequence #(mem_transaction);
  `uvm_object_utils(mem_sequence)
  function new(string name="mem_sequence"); super.new(name); endfunction
  virtual task body();
    mem_transaction tx;
    repeat (50) begin
      tx = mem_transaction::type_id::create("tx");
      assert(tx.randomize());
      start_item(tx);
      finish_item(tx);
    end
  endtask
endclass

uvm/mem_driver.sv
class mem_driver extends uvm_driver #(mem_transaction);
  `uvm_component_utils(mem_driver)
  virtual mem_if vif;
  function new(string name, uvm_component parent); super.new(name, parent); endfunction
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (!uvm_config_db#(virtual mem_if)::get(this,"","vif",vif))
      `uvm_fatal("NOVIF","No vif")
  endfunction
  task run_phase(uvm_phase phase);
    forever begin
      mem_transaction tx;
      seq_item_port.get_next_item(tx);
      vif.addr       <= tx.addr;
      vif.data       <= tx.data;
      vif.read_write <= tx.read_write;
      vif.valid      <= 1;
      @(posedge vif.clk);
      wait (vif.ready);
      vif.valid <= 0;
      seq_item_port.item_done();
    end
  endtask
endclass

uvm/mem_monitor.sv
class mem_monitor extends uvm_monitor;
  `uvm_component_utils(mem_monitor)
  virtual mem_if vif;
  uvm_analysis_port #(mem_transaction) item_collected_port;
  function new(string name, uvm_component parent);
    super.new(name, parent);
    item_collected_port = new("item_collected_port", this);
  endfunction
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if (!uvm_config_db#(virtual mem_if)::get(this,"","vif",vif))
      `uvm_fatal("NOVIF","No vif")
  endfunction
  task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.clk);
      if (vif.valid && vif.ready) begin
        mem_transaction tx = mem_transaction::type_id::create("tx");
        tx.addr = vif.addr;
        tx.data = vif.data;
        tx.read_write = vif.read_write;
        item_collected_port.write(tx);
      end
    end
  endtask
endclass

uvm/mem_agent.sv
class mem_agent extends uvm_agent;
  `uvm_component_utils(mem_agent)
  mem_sequencer sequencer;
  mem_driver    driver;
  mem_monitor   monitor;
  virtual mem_if vif;
  function new(string name, uvm_component parent); super.new(name,parent); endfunction
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    monitor   = mem_monitor::type_id::create("monitor",this);
    if (get_is_active() == UVM_ACTIVE) begin
      sequencer = mem_sequencer::type_id::create("sequencer", this);
      driver    = mem_driver::type_id::create("driver", this);
    end
  endfunction
  function void connect_phase(uvm_phase phase);
    if (get_is_active() == UVM_ACTIVE)
      driver.seq_item_port.connect(sequencer.seq_item_export);
  endfunction
endclass

uvm/mem_scoreboard.sv
class mem_scoreboard extends uvm_subscriber #(mem_transaction);
  `uvm_component_utils(mem_scoreboard)
  uvm_analysis_imp #(mem_transaction, mem_scoreboard) trans_collector;
  mailbox expected;
  function new(string name, uvm_component parent);
    super.new(name, parent);
    trans_collector = new("trans_collector", this);
    expected = new();
  endfunction
  function void write(mem_transaction tx);
    expected.put(tx);
  endfunction
  virtual function void write(muvm_analysis_imp #(mem_transaction, mem_scoreboard) imp, mem_transaction tx);
    mem_transaction exp;
    if (expected.try_get(exp)) begin
      if (!tx.do_compare(exp,null))
        `uvm_error("MISMATCH","Driver vs Monitor data mismatch");
    end else `uvm_error("MISSING","No expected transaction in scoreboard");
  endfunction
endclass

uvm/mem_env.sv
class mem_env extends uvm_env;
  `uvm_component_utils(mem_env)
  mem_agent       agent;
  mem_sequence    seq;
  mem_scoreboard  sb;
  function new(string name, uvm_component parent); super.new(name,parent); endfunction
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    agent = mem_agent::type_id::create("agent", this);
    sb    = mem_scoreboard::type_id::create("sb", this);
  endfunction
  function void connect_phase(uvm_phase phase);
    agent.monitor.item_collected_port.connect(sb.trans_collector);
  endfunction
endclass

uvm/mem_test.sv
class mem_test extends uvm_test;
  `uvm_component_utils(mem_test)
  mem_env env;
  function new(string name, uvm_component parent); super.new(name,parent); endfunction
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    env = mem_env::type_id::create("env", this);
  endfunction
  task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    mem_sequence seq = mem_sequence::type_id::create("seq");
    seq.start(env.agent.sequencer);
    phase.drop_objection(this);
  endtask
endclass


ğŸš€ íƒ‘ ë ˆë²¨ ë° ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
top.sv
`timescale 1ns/1ps
import uvm_pkg::*;
`include "uvm_macros.svh"

module top;
  logic clk, reset;
  initial clk = 0; always #5 clk = ~clk;

  mem_if memif(clk);

  simple_mem dut (
    .clk(clk), .reset(reset),
    .addr(memif.addr), .data(memif.data),
    .read_write(memif.read_write), .valid(memif.valid),
    .ready(memif.ready), .rdata()
  );

  initial begin
    reset = 1; #20; reset = 0;
  end

  initial begin
    uvm_config_db#(virtual mem_if)::set(null, "env.agent.driver", "vif", memif);
    run_test("mem_test");
  end
endmodule

ì»´íŒŒì¼/ì‹¤í–‰ (VCS ê¸°ì¤€)
# Makefile
all:
	vcs -sverilog -ntb_opts uvm \
	+incdir+uvm +incdir+uvm_mem_project/uvm +incdir+uvm_mem_project/dut \
	top.sv \
	dut/*.sv uvm/*.sv \
	-l sim.log

run: all
	./simv


ğŸ§© ê¸°ëŒ€ ë™ì‘ ìš”ì•½
ì‹œí€€ìŠ¤ì—ì„œ ëœë¤ mem_transaction 50ê°œ ìƒì„±
Driverê°€ mem_ifì— ê°’ì„ ì ìš©í•˜ê³  handshake
Monitorê°€ valid/ready ì‹œì ì— íŠ¸ëœì­ì…˜ ìˆ˜ì§‘
Scoreboardê°€ queueë¥¼ í†µí•´ ìˆœì„œ ë¹„êµ
Assertion ì—†ìŒ (DUT ë‹¨ìˆœ ë©”ëª¨ë¦¬), mismatch ì‹œ ì—ëŸ¬ ë°œìƒ
UVM ë¦¬í¬íŠ¸ ë¡œê·¸ ë° scoreboard ë¹„êµ ê²°ê³¼ ì¶œë ¥
